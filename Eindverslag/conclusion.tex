\chapter{Conclusion}
\label{sec:conclusion}
During the past weeks we have created a platform where teachers can create the practicals associated with their MOOC and where students can enrol for practicals and form practical groups to work together on assignments.
This platform serves as a proof of concept for the various problems that were mentioned in the problem description.
One of the problems is the scale of MOOCs, which makes searching for a good group member is not a trivial problem.
To assist the student in forming a good group, the platform recommends possible group members to the searching student.

We split the project in three phases: the orientation phase, the implementation phase and the final phase.
The project started off with the orientation phase in which the different aspects of the problem description were analysed.
During this time we looked into what kind of recommendation algorithm we would be using.
We also made an extensive list of requirements that helped us set out the different design decisions.
Lastly, we made a basic system design.
In the next phase, the implementation phase, we incrementally implemented the different features of the system.
At the end of the implementation phase we started the user tests.
With these user tests we tested the interface and basic usage of the system.
During the last phase we finished up the last features and we focused on documenting the project in this report.
We also received the feedback of SIG on the maintainability of our source code, one of the things done in the last phase was to improve the source code using this feedback.
The last thing to be done in the last phase is looking in what ways we can improve on the final product.
This is discussed in the future work section later this chapter.

%Uitleggen wat we in dit document hebben beschreven
This report described the entire project.
We started with introducing the problem and our target audience.
Secondly, the report described our supervisors, the different actors of the system, global goals, global requirements and detailed requirements.
Following this, we described the project methodology we have chosen and we discussed how it panned out for us.
Per phase we described the goal, planning and deliverables of the phase.
We also reflected on each phase separately.
In chapter 4 we described the design we made of the system and how we implemented specific parts.
Things that we discuss in this chapter: Database diagram, class diagram, state diagrams, sequence diagrams, MVC, implementation of the recommendation algorithm and implementation of the invitation system.
Next, we described the different kinds of testing that has been done during the project.
We started with describing the different kinds of testing that we have done during the implementation phase, followed by the testing that we have done after the implementation phase.
During the implementation phase we made use of unit testing and integration testing.
After the implementation phase we made use of a user test and requirements test.
Lastly, we described the feedback that we have received from SIG and how we thought on improving this feedback.

\textbf{The final product, that will be presented, will be a working proof of concept which will fit closely with the specified target audience and demands of the assignment.}\\
To determine whether this goal has been met, we can look at the requirements.
The requirements have been set up with the target audience and the problem description in mind.
The problem description states the following important problems that need to be solved by the system:
\begin{itemize}
\item Difficulty finding a good practical partner.
\item Searching for a practical partner is a time consuming process.
\item Sub optimal solution, people often look for group members which share some interests.
While this often makes it easy to work together, this will not guarantee that you have a good functioning group with enough knowledge.
\end{itemize}

Looking at the requirements, we can definitely see that these problems are well represented by the requirements.
During the project we focussed on implementing these requirements.
It is no surprise that the resulting product is a proof of concept for the solutions that we have selected to solve the problems mentioned above.

To determine how well our proof of concept solves the problems we will have to look at to what extent we have implemented the requirements.
We will make that comparison in the other goals, since those goals were focussed  more on what the system should be able to do.

\textbf{We want to create a platform for searching other students and letting the students invite other students for a practical group.}\\
We have achieved this goal by creating a website and implementing an invitation system for this website.
Using this invitation system, students can search and invite one another.
This invitation system gives students the possibilities to invite both single students as groups of students.
It also gives groups the possibilities to invite both single students as groups of students.
The invitation system gives the user all the possible actions needed for the process of creating a practical group.

We can verify the completion of these features by looking at the requirements test.
The requirements clearly states which requirements have been implemented and which requirements have not.
The requirements test also clearly states that all the must and should haves concerning the creation of a platform for searching and inviting other students have been implemented.

\textbf{We want the final product to recommend good fitting possible group members to the students.
By "good fitting" we mean that there is some heuristic that we use to calculate whether two students would make a good practical group.
We want the final product to achieve more optimal solutions than the current situation}\\
In our research report we wrote extensively about what aspects are important to our recommendation algorithm.
Questions that we asked ourselves at the start of our research were:
\begin{itemize}
\item How does the algorithm determine a possible practical partner?
\item How does the algorithm make a difference between two possible partners and determine which one is a better fit?
\item How does the algorithm make use of the extra information provided if the could haves are implemented?
\item How does it make sure the partner that is recommended hasn't already been suggested?
\end{itemize}

We tried answering these questions using known techniques like knowledge-base recommendations, content-based recommendation, collaborative recommendation and demographic recommendation.
After doing research we concluded that the known techniques did solve all our problems.
We thus choose to select aspects of some techniques and combine these to a complete solution.
We decided upon the following aspects:
\begin{itemize}
\item The algorithm uses the idea of social interaction platform that is based off the platform that the Tinder app uses.
\item The algorithm uses a knowledge-based approach to deal with the various kinds of user information.
\item We use the geometric mean that is used by OKCupid's algorithm to calculate the differences and similarities between users.
\item We would like to make the algorithm robust for cold-start problems, the usage of a knowledge-based approach should help with this.
\end{itemize}

We do not have a guarantee of the performances of our algorithm, but we can say that our algorithm is perfectly tailored for the problems that were mentioned in the problem description.
We can improve on our understanding of the implemented algorithm and it's results by creating simulations.
These simulations would simulate the different actions of the system and will simulate both the use of the system as the use of the algorithm.
Due to the time limits of the project we did not get to implementing these simulations.

Using the requirements test of chapter 5 we can say that we have done a good job implementing the must and should haves that are focused on these problems.
The only thing we have fallen short in, is the fact that we deal with a wide target audience.
MOOC's are open to all people and we have not spend enough time writing an explanation of the system.

\textbf{We want the maintainability of the final product to very high and want the code to be easily extendable.}\\
Maintainability is very important in creating a software product, because it is important to easily solve defects, replace worn-out components, meet new requirements, etc.
While programming, all these aspects are very important.
In chapter 5 we have discussed the SIG feedback and have seen that our maintainability scores above average.
This will be improved after the analytics we have done on the improvement points on the SIG feedback.

After the analysis we will try to improve our maintainability by making the software more modular. 
The improvements we have made after finishing this report will further be discussed in our presentation.
For now we are happy with the three stars that we have scored.

\subsection{Recommendations for future work}
Although we managed to implement most of the must and should haves that were important for the goals of the project, there is still much room for improvement.
There is room for improvement in different aspects of the system and some have a higher priority than others.
Below we will list the different aspects that can be improved upon, we introduce a general direction for improvement, discuss shortly why improving this aspect will improve the system in general and it's priority.

\begin{itemize}
\item First on the list of improvements is implementing the last two remaining must haves.
This improvement has a high priority because it makes the proof of concept much more complete and usable.
The proof of concept would be a better representation of the system that is needed.
Our goal is to implement these two before the presentation.

\item The recommendation above already describes some of the improvements that can be made to the user interface.
Other improvements can be found in the interface mock-ups that are not yet implemented.
Implementing these interface mock-ups will drastically improve the user interface.
These have a moderate priority due to the focus being on having a working system.
The priority will increase when the focus will be shifted towards the usage of the system.

\item The user test revealed some errors in our system that our tests did not find.
Fixing these errors is high on our priority list and definitely something we want to look into during the time until presentation.
Due to it being errors, they are high on our priority list.
We want to deliver a complete and working proof of concept and this is a part of 
that.

\item Although we deliver a working proof of concept, it is difficult to verify the performance of our recommendation algorithm and our system.
This would need either a large user test or a simulation.
We think that the implementation of a simulation would help to understand and verify the working of the current system.
This simulation will simulate the process of using the system and by doing this try to measure the performance of the recommendation algorithm and the system.

\item To improve the recommendations that the algorithm gives more information is needed.
This can be done by adding more skills for the user to fill in.
Increasing the amount of skills that the user provides will increase the accuracy in which the algorithm can recommend.
This could be done by letting the user rate him-/herself for more skills, this is the easiest solution for this improvement.
But other ways of rating user skills might be more beneficial to the system.
These other ways might be the user answering questions which are related to the subjects.
The answers can then be rated to determine the score of the different users.

\item We already mentioned some possible improvements that will increase the accuracy of the algorithm.
These improvements were based on using more data in the recommendation.
Another way of improving the algorithm is by adding another technique to the recommendation algorithm.
An example of this is a rating of the recommendation by the user.
The algorithm has to be adjusted so it can use these ratings to further improve his recommendation.

\item In the requirements test we have mentioned that we have implemented all the must and should have requirements that are connected to the focus and goals of the project.
The next step for this product is towards work to version which will be used in a live situation.
This will result in more features that will have to be implemented.
One of the things that need to be done will be implementing a more advanced practical management system for the teacher.
In that way the product will be more attractive to the people that have the choice to start using it.
It will not have a big initial priority, but will increase in priority when the product will be focussed more on live usage.
\end{itemize}




