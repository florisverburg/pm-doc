\chapter{Conclusion}
\label{sec:conclusion}
During the past weeks we have created a platform where teachers can create the practicals associated with their MOOC and where students can enrol for practicals and form practical groups to work together on assignments.
This platform serves as a proof of concept for the various problems that were mentioned in the problem description.
One of the problems is the scale of MOOC's, which makes searching for a good group member is not a trivial problem.
To assist the student in forming a good group, the platform recommends possible group members to the searching student.

We split the project up in three phases: the orientation phase, the implementation phase and the final phase.
The project started off with the orientation phase in which the different aspects of the problem description were analysed.
During this time we looked into what kind of recommendation algorithm we will be using.
We also made an extensive list of requirements that helped us set out the different design decisions.
Lastly, we made a basic system design.
In the next phase, the implementation phase, we incrementally implemented the different features of the system.
At the end of the implementation phase we started the user tests.
With these user tests we tested the interface and basic usage of the system.
During the last phase we finished up the last features and we focused on documenting the project in this report.
We also received the feedback of SIG on the maintainability of our source code, one of the things done in the last phase was to improve the source code using this feedback.
The last thing to be done in the last phase is looking in what ways we can improve on the final product.
This is discussed in the future work section later this chapter.

%Uitleggen wat we in dit document hebben beschreven
This report documents the entire project.
We start with introducing the problem and our target audience.
Secondly, the report describes our supervisors, the different actors of the system, global goals, global requirements and detailed requirements.
Following this, we describe the project methodology we have chosen and we discuss how it panned out for us.
Per phase we describe the goal, planning and deliverables of the phase.
We also reflect on each phase separately.
In chapter 4 we describe the design we made of the system and how we implemented specific parts.
Things that we discuss in this chapter: Database diagram, class diagram, state diagrams, sequence diagrams, MVC, implementation of the recommendation algorithm and implementation of the invitation system.
Next, we describe the different kinds of testing that has been done during the project.
We start with describing the different kinds of testing that we have done during the implementation phase, followed by the testing that we have done after the implementation phase.
During the implementation phase we made use of unit testing and integration testing.
After the implementation phase we made use of a user test and requirements test.
Lastly, we describe the feedback that we have received from SIG and how we think to improve on this feedback.

\textbf{The final product, that will be presented, will be a working proof of concept which will fit closely with the specified target audience and demands of the assignment.}
To determine whether this goal has been met, we can look at the requirements.
The requirements have been set up with the target audience and the problem description in mind.
The problem description states the following important problems that need to be solved by the system:
\begin{itemize}
\item Difficulty finding a good practical partner.
\item Searching for a practical partner is a time consuming process.
\item Sub optimal solution, people often look for group members which share some interests.
While this often makes it easy to work together, this will not guarantee that you have a good functioning group with enough knowledge.
\end{itemize}

Looking at the requirements, we can definitely see that these problems are well represented by the requirements.
During the project we focussed on implementing these requirements.
It is no surprise that the resulting product is a proof of concept for the solutions that we have selected to solve the problems mentioned above.

To determine how well our proof of concept solves the problems we will have to look at to what extent we have implemented the requirements.
We will make that comparison in the other goals, since those goals were focussed  more on what the system should be able to do.

\textbf{We want to create a platform for searching other students and letting the students invite other students for a practical group.}

We have achieved this goal by creating a website and implementing an invitation system for this website.
Using this invitation system, students can search and invite one another.
This invitation system gives students the possibilities to invite both single students as groups of students.
It also gives groups the possibilities to invite both single students as groups of students.
The invitation system gives the user all the possible actions needed for the process of creating a practical group.

We can verify the completion of these features by looking at the requirements test.
The requirements clearly states which requirements have been implemented and which requirements have not.
The requirements test also clearly states that all the must and should haves concerning the creation of a platform for searching and inviting other students have been implemented.

\textbf{We want the final product to recommend good fitting possible group members to the students.
By "good fitting" we mean that there is some heuristic that we use to calculate whether two students would make a good practical group.
We want the final product to achieve more optimal solutions than the current situation}

In our research report we wrote extensively about what aspects are important to our recommendation algorithm.
Questions that we asked ourselves at the start of our research were:
\begin{itemize}
\item How does the algorithm determine a possible practical partner?
\item How does the algorithm make a difference between two possible partners and determine which one is a better fit?
\item How does the algorithm make use of the extra information provided if the could haves are implemented?
\item How does it make sure the partner that is recommended hasn't already been suggested?
\end{itemize}

We tried answering these questions using known techniques like knowledge-base recommendations, content-based recommendation, collaborative recommendation and demographic recommendation.
After doing research we concluded that the known techniques did solve all our problems.
We thus choose to select aspects of some techniques and combine these to a complete solution.
We decided upon the following aspects:
\begin{itemize}
\item The algorithm uses the idea of social interaction platform that is based off the platform that the Tinder app uses.
\item The algorithm uses a knowledge-based approach to deal with the various kinds of user information.
\item We use the geometric mean that is used by OKCupid's algorithm to calculate the differences and similarities between users.
\item We would like to make the algorithm robust for cold-start problems, the usage of a knowledge-based approach should help with this.
\end{itemize}

We do not have a guarantee of the performances of our algorithm, but we can say that our algorithm is perfectly tailored for the problems that were mentioned in the problem description.
We can improve on our understanding of the implemented algorithm and it's results by creating simulations.
These simulations would simulate the different actions of the system and will simulate both the use of the system as the use of the algorithm.
Due to the time limits of the project we did not get to implementing these simulations.

Using the requirements test of chapter 5 we can say that we have done a good job implementing the must and should haves that are focused on these problems.
The only thing we have fallen short in, is the fact that we deal with a wide target audience.
MOOC's are open to all people and we have not spend enough time writing an explanation of the system.

Maintainability is very important in creating a software product, because it is important to easily solve defects, replace worn-out components, meet new requirements, etc.
While programming, all these aspects are very important.
In chapter 5 we have discussed the SIG feedback and have seen that our maintainability scores above average.
This will be improved after the analytics we have done on the improvement points on the SIG feedback.

After the analysis we will try to improve our maintainability by making the software more modular. 
The improvements we have made after finishing this report will further be discussed in our presentation.
For now we are happy with the three stars that we have scored.
