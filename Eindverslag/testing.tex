\chapter{Testing}
In this chapter we will be talking about the different techniques that we have employed to test the different aspects of the system.
We will first be talking about the different kind of unit tests that we have written.
These tests provide for a basic code coverage.
After this we will be talking about what kind integration tests we have performed to ensure the connection between the different components.
Lastly we will be talking about the acceptance tests that were performed.

\section{Testing methods during the implementation phase}
\subsection{Unit testing}
During the implementation phase a feature is only complete when it is fully tested.
This is done by running the system and testing it by the programmer, but also done by running automated tests.
These automated tests are required for achieving a good code coverage and for ensuring the code to work appropriately.
The tests that are written for other features will be always run after the feature has been merged.
This ensures that other features that may change the working of the code does not let the tests fail.
So all the features that were already in the system will still work even after the merging of the new feature.

In the following image you can see the increasing amount of tests that increase with each pull request that has been merged.
%Insert image of dev branch

In the second image you can see the increasing amount of tests of the different pull requests that have been made.
In this image you can clearly see that when sometimes when a new feature is added, some tests start to fail.
Due to our continuous integration we could spot the errors early and make sure that they are fixed before merging with the development branch.
%Insert image of pull request

The third image depicts the code coverage achieved by the tests.
The goal is to have the code coverage percentages to be around a certain percentage during the entire implementation.
One could argue that a 100\% code coverage is desired, but some features are quite trivial and don't need a 100\% code coverage.
Next to this is the fact that some plugins, in our case the eBean plugin, generates code for classes.
This generated code is not something we need to test since it is not written by us.
We also underestimated the complexity of some features and thus did not wrote the tests for all cases with the first pull request of those features.
In that first basic implementation some of the cases were already implemented in part of the system but not actually called upon and made available from the front end.
We thus decided to first create a pull request for a basic version and thus split up the amount of changes.
Later, when the feature was further implemented, we added tests that would test these extra cases.

%Insert image of the test code coverage


\subsection{Integration testing}
Everything a pull request was made, the changes were checked by a member of the team that wasn't the one requesting the merge.
This ensured that the changes made reflected the feature that was selected to be implemented.
The member of the team to check the code asked questions about some changes and checked if complex functions could be made more efficient.
Although we use checkstyle and findbugs to perform code analysis, they do not find everything.
So there is much value to achieve with a member of the team checking the code.

In the following image you can see an example of a pull request and how a team member commented on a part of the code.
The requesting team member responded on the issue and argued why he choose the implementation.

%Insert image of an example pull request with a comment

For an overview of the pull request and the comments that were made, you can find more information on the following website:
https://github.com/florisverburg/pm-impl/pulls

\section{Testing methods after the implementation phase}
The testing of the entire system is done after the implementation phase has been completed.
This is partly done by checking if the final product matches the requirements set.
It is also done by letting the target audience use the system and document the findings.
We will start with describing the user tests.

\subsection{User test}
The purpose of the user test is to test the system without the limiting factors of a development environment.
The system will be tested for his robustness in the different kinds of input a user can generate.
The test also let's the user make extensive use of the interface that we provided.
Any errors will be revealed by the user interaction.

To test the system we will be defining the people that are valid testing subjects and how we documented the various aspects of the test.

\subsubsection{The user}
We define a valid subject for our user test as a person that is part of the target audience (which we already defined in an earlier chapter).
The user should also be unfamiliar with the system.

\subsubsection{The test}
The user will be asked to test different functionalities which we will define beforehand.
We hand the user a document which lists the different actions that we want the user to do.
Before and after the test we let the user fill in a survey.
The survey at the start is about who the user is and the survey at the end is about what they thought of the system.
The surveys and instruction document can be found in the appendix.

\subsubsection{The user test results}

\subsection{Requirements test}
%Each of the requirements is listed and compared to the result


